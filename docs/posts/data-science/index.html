<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Unpacking the Machine Learning Process: A Practical Step-by-Step Guide – Data Science Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Data Science Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Unpacking the Machine Learning Process: A Practical Step-by-Step Guide</h1>
            <p class="subtitle lead">Hands-On Demo with Logistic Regression on the Pima Indians Diabetes Dataset</p>
                                <div class="quarto-categories">
                <div class="quarto-category">tutorial</div>
                <div class="quarto-category">code</div>
                <div class="quarto-category">analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Machine learning (ML) is a powerful tool for solving complex problems by identifying patterns in data. However, to build a successful machine learning model, it’s essential to follow a structured process that takes raw data and transforms it into actionable insights. In this tutorial, I will walk through the essential steps of the ML process using logistic regression model on a real-world dataset: the <a href="https://www.kaggle.com/datasets/uciml/pima-indians-diabetes-database">Pima Indians Diabetes Dataset</a> (the ‘diabetes dataset’).</p>
<p>THe demo is coded in <a href="https://www.python.org/">Python</a> and the primary machine learning software for modeling is <a href="https://scikit-learn.org/stable/">scikit-learn</a>, which is an open-source library for Python that offers an extensive range of supervised and unsupervised learning algorithms and tools for machine learning tasks. You can find all source code that supports the demo in this <a href="https://github.com/UBC-MDS/diabetes_predictor_py">GitHub repository</a> and the final research report <a href="https://ubc-mds.github.io/diabetes_predictor_py/reports/diabetes_analysis.html">here</a>.</p>
<section id="step-1-define-the-problem" class="level3">
<h3 class="anchored" data-anchor-id="step-1-define-the-problem"><strong>Step 1: Define the Problem</strong></h3>
<p>Before diving into code or models, the first step is always to <strong>define the problem</strong> clearly. Understanding the business problem or the task we are trying to solve is critical, as it determines the approach and the tools we’ll use.</p>
<ul>
<li><strong>What problem are we trying to solve?</strong></li>
<li><strong>Is it a classification task, regression task, or clustering task?</strong></li>
<li><strong>What kind of data do we have, and what’s the expected output?</strong></li>
</ul>
<p>In this guide, our goal is to predict whether a person has diabetes based on clinical features like glucose levels, BMI, and age. This is a binary classification problem, where the output variable is whether or not the patient has diabetes.</p>
</section>
<section id="step-2-understand-and-validate-the-data" class="level3">
<h3 class="anchored" data-anchor-id="step-2-understand-and-validate-the-data"><strong>Step 2: Understand and Validate the Data</strong></h3>
<p>Machine learning models rely on high-quality data to learn and make predictions, so it is crucial to understand the data before applying any machine learning techniques.</p>
<section id="source-collection-and-scope-of-data" class="level4">
<h4 class="anchored" data-anchor-id="source-collection-and-scope-of-data"><u>Source, Collection, and Scope of Data</u></h4>
<p>The initial stage in understanding any dataset is to get a high-level overview of its source, collection process, and scope. This includes addressing the following questions:</p>
<ul>
<li><strong>Where is the data coming from?</strong></li>
<li><strong>How was the data collected?</strong></li>
<li><strong>How many observations are there?</strong></li>
<li><strong>What relevant features are available?</strong></li>
</ul>
<p>By understanding these aspects, we can assess the dataset’s relevance and reliability for the machine learning task at hand. For example, Pima Indians Diabetes Dataset is well-aligned with the goal of predicting diabetes, as it comes from a reliable source, the National Library of Medicine, is based on standardized medical examinations, and provides a sufficient sample size with 768 observations <span class="math inline">\(\times\)</span> 8 features for meaningful model training and evaluation.</p>
</section>
<section id="data-validation" class="level4">
<h4 class="anchored" data-anchor-id="data-validation"><u>Data Validation</u></h4>
<p>Following the top level summary on the dataset, the next critical step is to ensures the quality, integrity, and consistency of the dataset such as checking for issues like missing values, outliers, duplicates, and adhering to expected data formats, types, and ranges. For instance, are the glucose levels within a reasonable range, or are there any negative values in fields like age or pregnancies?</p>
<p>Tools like the <a href="https://pandera.readthedocs.io/en/stable/">Pandera</a> package can automate this process by allowing us to define validation schemas for the dataset, ensuring that each column meets predefined conditions. It is important to note that data validation focuses on identifying and addressing inherent issues in the dataset, rather than making subjective judgments or imposing interpretations on the data. This means, in the diabetes dataset, observations are removed when they contain implausible values, like nulls or zeros, in features where these values would be unrealistic (e.g., glucose or blood pressure).</p>
</section>
</section>
<section id="step-3-split-the-data-into-training-and-testing-sets" class="level3">
<h3 class="anchored" data-anchor-id="step-3-split-the-data-into-training-and-testing-sets"><strong>Step 3: Split the Data into Training and Testing Sets</strong></h3>
<p>Before proceeding any further with data exploration, it’s important to split the data into two subsets: one for training and one for testing.</p>
<p>This division is essential for evaluating how well our model generalizes to unseen data. A common split is <strong>70% for training and 30% for testing</strong>, where the training set is used to teach the model, and the test set is reserved to measure its true performance upon the model is properly trained. Keeping the test set “locked” and untouched until the final evaluation is critical for ensuring that the model’s performance is not influenced by prior knowledge of this data.</p>
<p>It is <strong>VERY important</strong> to perform this split early so we avoid any potential <strong>data leakage</strong> and adhere to the <strong>golden rule of machine learning</strong>: the test data cannot influence training the model in anyway.</p>
</section>
<section id="step-4-exploratory-data-analysis-eda" class="level3">
<h3 class="anchored" data-anchor-id="step-4-exploratory-data-analysis-eda"><strong>Step 4: Exploratory Data Analysis (EDA)</strong></h3>
<p>Once we’ve split the dataset, we can dive deeper into Exploratory Data Analysis (EDA) on the <strong>training data</strong>. EDA involves investigating the dataset’s structure and characteristics using both visualizations and statistical methods. By looking at key aspects such as missing values, the distribution of features, and visualizing how different features relate to the target variable, we gain a clear understanding of the data, uncover patterns, and identify any potential issues that might affect model performance.</p>
<p>In our demo, <a href="#fig-feature_histograms" class="quarto-xref">Figure&nbsp;1</a> visualized the distributions of each predictor from the diabetes training set, with the distributions color-coded by class (0: blue, 1: orange). This exploration often helps identify patterns or trends that inform <a href="#feature-engineering">feature engineering</a> later in the process.</p>
<div id="fig-feature_histograms" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-feature_histograms-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/feature_histograms.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-feature_histograms-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Comparison of the empirical distributions of training data predictors between those non-diabetic and diabetic. Image by Author.
</figcaption>
</figure>
</div>
<p>Moroever, we also examined correlation among the predictors (<a href="#fig-correlation_heatmap" class="quarto-xref">Figure&nbsp;2</a>) to identify multicollinearity, which could cause problems when performing logistic regression. No multicollinearity was detected, as the highest correlation between predictors is below the 0.7 threshold.</p>
<div id="fig-correlation_heatmap" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-correlation_heatmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/correlation_heatmap.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-correlation_heatmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Pearson and Spearman correlations across all features. Image by Author.
</figcaption>
</figure>
</div>
</section>
<section id="step-5-data-preprocessing" class="level3">
<h3 class="anchored" data-anchor-id="step-5-data-preprocessing"><strong>Step 5: Data Preprocessing</strong></h3>
<p>This phase, known as data preprocessing, involves cleaning and transforming the raw data to make it suitable for machine learning algorithms. It includes handling missing values, transforming features, and performing feature engineering. Proper data preprocessing is crucial as it directly impacts the performance and accuracy of the machine learning model.</p>
<section id="handling-missing-data" class="level4">
<h4 class="anchored" data-anchor-id="handling-missing-data"><u>Handling Missing Data</u></h4>
<p>Addressing missing or invalid data is one of the first preprocessing tasks. Typically missing data is handled by:</p>
<ul>
<li><strong>Removing rows</strong> with missing values if they are few and don’t significantly affect the dataset.</li>
<li><strong>Imputing missing values</strong> using a statistical method, such as replacing them with the median, mean, or mode of the feature, or more sophisticated techniques such as predictive imputation.</li>
</ul>
<p>Choosing the right approach for missing data depends on the nature of the dataset and the amount of missing data present.</p>
</section>
<section id="feature-transformation" class="level4">
<h4 class="anchored" data-anchor-id="feature-transformation"><u>Feature Transformation</u></h4>
<p>Feature transformation ensures that different types of data are appropriately scaled or encoded so that machine learning algorithms can interpret them correctly. The methods used vary depending on the type of data: numeric, categorical, and textual.</p>
<p><em>1. Numeric Data</em></p>
<p>For numeric data, many machine learning algorithms benefit from scaling the features to a similar range. This helps ensure that one feature does not disproportionately influence the model compared to other features. Common approaches to numeric feature transformation include:</p>
<ul>
<li><strong>Standardization:</strong> Rescales features to have a mean of 0 and a standard deviation of 1, often used for algorithms like logistic regression.</li>
<li><strong>Normalization:</strong> Scales features to a fixed range (e.g., 0 to 1), commonly used in distance-based algorithms like k-nearest neighbors (k-NN) model.</li>
</ul>
<p><em>2. Categorical Data (Nominal and Ordinal)</em></p>
<p>Categorical data consists of non-numeric values that represent discrete categories or labels, which cannot be directly used by machine learning models. Common methods of transformtion include:</p>
<ul>
<li><strong>One-Hot Encoding:</strong> This method creates binary (0 or 1) columns for each category, turning a single categorical feature with multiple categories into several binary features. This is often used for nominal data, where the categories do not have a meaningful order (e.g., “female” vs.&nbsp;“male”).</li>
<li><strong>Label Encoding:</strong> This approach converts each category into a numeric label, which is suitable for ordinal data where there is a meaningful order (e.g., “low”, “medium”, “high”).</li>
</ul>
<p><em>3. Text Data</em></p>
<p>Raw text data, such as sentences, documents, or reviews, contains valuable information but cannot be directly interpreted by algorithms. Feature transformation techniques are used to convert text into a numerical format for machine learning models to process effectively.</p>
<ul>
<li><strong>Bag-of-Words:</strong> Transforms text into numerical features by counting word occurrences in documents, creating a sparse matrix.</li>
<li><strong>TF-IDF (Term Frequency-Inverse Document Frequency):</strong> Weighs word frequencies by their importance across the dataset, down-weighting common words like “the” and “is.”</li>
</ul>
</section>
<section id="feature-engineering" class="level4">
<h4 class="anchored" data-anchor-id="feature-engineering"><u>Feature Engineering</u></h4>
<p>Feature engineering refers creating new features from the existing dataset to better represent the underlying patterns in the data. This step is often key to improving the predictive power of the model. This often includes creating interaction terms (e.g.&nbsp;squared or cubic terms), adding polynomial features, and sometimes aggregating multiple features.</p>
<p>In our case, the diabetes dataset already contains structured numeric data that only required scaling, but feature engineering such as interaction terms could have been explored to better capture relationships between features.</p>
<p><strong><em>Important Note on Data Integrity</em></strong></p>
<p>The procedures and techniques in this section highlight why it’s crucial to <a href="#step-3-split-the-data-into-training-and-testing-sets">split the data</a> before starting any preprocessing. For example, imagine applying a feature scaling technique like standardization, where we calculate the mean and standard deviation of a feature. If we compute these statistics using both the training and testing data, we would inadvertently introduce information from the test set into the training process, resulting in data leakage by giving the model an unfair advantage and inflating its performance.</p>
<p>By splitting the data first, we ensure the integrity of the test set for unbiased evaluation is preserved. Mechanically, we fit the transformation models (such as scaling or encoding) only on the training data, and then apply the same transformations to both the training and testing data, ensuring consistency without contaminating the test set.</p>
</section>
</section>
<section id="step-6-choose-a-model" class="level3">
<h3 class="anchored" data-anchor-id="step-6-choose-a-model"><strong>Step 6: Choose a Model</strong></h3>
<p>At this stage, choose a <strong>machine learning model</strong> to solve our problem. The choice of model depends on the problem type, the nature of the data, and the available computational resources.</p>
<ul>
<li><strong>Classification problems</strong>: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html">Logistic regression</a>, <a href="https://scikit-learn.org/stable/modules/tree.html">decision trees</a>, <a href="https://scikit-learn.org/stable/modules/ensemble.html#random-forests-and-other-randomized-tree-ensembles">random forests</a>, <a href="https://scikit-learn.org/stable/modules/svm.html">support vector machines (SVM)</a>, <a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html">k-NN</a>, etc.</li>
<li><strong>Regression problems</strong>: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html">Linear regression</a>, decision trees, random forests, etc.</li>
<li><strong>Clustering problems</strong>: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html">K-means</a>, <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html">DBSCAN</a>, <a href="https://scikit-learn.org/stable/modules/clustering.html#hierarchical-clustering">hierarchical clustering</a>, etc.</li>
</ul>
<p>For this tutorial, we chose <strong>Logistic Regression</strong>, a simple yet powerful model for binary classification tasks. It models the probability of a binary outcome (e.g.&nbsp;diabetic vs.&nbsp;non-diabetic) based on the input features.</p>
</section>
<section id="step-7-train-the-model" class="level3">
<h3 class="anchored" data-anchor-id="step-7-train-the-model"><strong>Step 7: Train the Model</strong></h3>
<p>Once we’ve selected the model, it’s time to train it on the training data. Training involves feeding the features and corresponding target values to the model so that it can learn the patterns and relationships between them.</p>
<section id="cross-validation" class="level4">
<h4 class="anchored" data-anchor-id="cross-validation"><u>Cross Validation</u></h4>
<p>Typically, we use cross-validation technique during training to improve the generalization ability of a machine learning model. It works by splitting the training data into multiple subsets, training the model on some folds, and validating it on the remaining fold. This process is repeated for each fold, and the average performance (along with standard deviation) is used to assess the model. Cross-validation helps mitigate overfitting and provides a more reliable estimate of the model’s performance on unseen data.</p>
</section>
<section id="hyperparameter-tuning" class="level4">
<h4 class="anchored" data-anchor-id="hyperparameter-tuning"><u>Hyperparameter Tuning</u></h4>
<p>For many machine learning models, there are hyperparameters that need to be tuned to optimize performance. Unlike model parameters, which are learned during training, hyperparameters are set before training and control the model’s learning process. Examples of hyperparameters include the learning rate in gradient descent, the number of trees in a random forest, or the regularization strength in logistic regression. Fine-tuning these hyperparameters can significantly impact the model’s ability to generalize to unseen data.</p>
<p>Common techniques for hyperparameter tuning include:</p>
<ul>
<li><strong>Grid Search</strong>, where a predefined set of hyperparameters is tested exhaustively</li>
<li><strong>Random Search</strong>, which samples hyperparameters randomly from a specified range.</li>
<li><strong>Advanced techniques</strong> such as <a href="https://github.com/bayesian-optimization/BayesianOptimization">Bayesian optimization</a>, <a href="https://medium.com/@byanalytixlabs/a-complete-guide-to-genetic-algorithm-advantages-limitations-more-738e87427dbb">genetic algorithms (GA)</a>, <a href="https://2020blogfor.github.io/posts/2020/04/hyperband/">hyperband</a>, etc.</li>
</ul>
<p>In the demo, the goal is to optimize the model to make accurate predictions for new data. The model finds the best-fit coefficients for the features to minimize the cost function (e.g., the log-loss function) for logistic regression. We’ve using <code>RandomizedSearchCV</code> to find the optimal regularization strength that minimizes the model’s error rate.</p>
</section>
</section>
<section id="step-8-evaluate-the-model" class="level3">
<h3 class="anchored" data-anchor-id="step-8-evaluate-the-model"><strong>Step 8: Evaluate the Model</strong></h3>
<p>After training the model, it’s essential to evaluate its performance on the test set. Evaluation allows us to measure how well the model generalizes to new, unseen data.</p>
<section id="evaluation-metrics" class="level4">
<h4 class="anchored" data-anchor-id="evaluation-metrics"><u>Evaluation Metrics</u></h4>
<p>Evaluation metrics help quantify this generalization by comparing the model’s predictions against the true outcomes. The choice of evaluation metrics depends on the type of problem and the characteristics of the data.</p>
<ul>
<li><strong>Classification Metrics:</strong> accuracy, precision, recall, f1-score, fbeta-score, ROC curve and AUC, PR curve and AP</li>
<li><strong>Regression Metrics:</strong> mean squared error (MSE), mean absolute error (MAE), mean absolute percentage error (mape), and R-squared (<span class="math inline">\(R^2\)</span>)</li>
<li><strong>Clustering Metrics:</strong> Clustering is an unsupervised learning task, and its evaluation metrics typically focus on measuring the similarity or compactness of the clusters formed. Evaluation metrics can be categorized into internal metrics, which assess clustering quality based solely on the data itself, and external metrics, which compare the clusters to pre-defined categories or ground truth.
<ul>
<li><u><em>Internal metrics:</em></u> silhouette score, Davies-Bouldin index, and Dunn index</li>
<li><u><em>External metrics:</em></u> Adjusted Rand Index (ARI), Normalized Mutual Information (NMI), and Fowlkes-Mallows Index (FMI)</li>
</ul></li>
</ul>
<p>Generally, accuracy for classification and mean squared error (MSE) for regression are set as default evaluation metrics in most machine learning software packages.</p>
<p>For the sample analysis, the model reported an accuracy score of 75%. More in depth evaluation of test set predictions include confusion matrix (<a href="#fig-test_confusion_matrix" class="quarto-xref">Figure&nbsp;3</a>), PR curve (<a href="#fig-test_pr" class="quarto-xref">Figure&nbsp;4</a>), and (<a href="#fig-test_roc" class="quarto-xref">Figure&nbsp;5</a>).</p>
<div id="fig-test_confusion_matrix" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-test_confusion_matrix-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/confusion_matrix_plot.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-test_confusion_matrix-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Confusion matrix of test set prediction accuracy. Image by Author
</figcaption>
</figure>
</div>
<div id="fig-test_pr" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-test_pr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/precision_recall_plot.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-test_pr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Precision recall curve and AP score of test set predictions. Image by Author.
</figcaption>
</figure>
</div>
<div id="fig-test_roc" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-test_roc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/roc_curve.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-test_roc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: ROC Curve and AUC score of test set predictions
</figcaption>
</figure>
</div>
</section>
</section>
<section id="step-9-refine-the-model" class="level3">
<h3 class="anchored" data-anchor-id="step-9-refine-the-model"><strong>Step 9: Refine the Model</strong></h3>
<p>After evaluating the model, we might find areas for improvement. This could involve:</p>
<ul>
<li><a href="#feature-engineering"><strong>Feature Engineering:</strong></a> Trying new features or transformations</li>
<li><a href="#hyperparameter-tuning"><strong>Hyperparameter Tuning:</strong></a> Using more advanced techniques to fine-tune the model’s parameters</li>
<li><strong>Trying Different Models:</strong> Experimenting other models if the chosen doesn’t perform well</li>
</ul>
</section>
<section id="step-10-deploy-the-model" class="level3">
<h3 class="anchored" data-anchor-id="step-10-deploy-the-model"><strong>Step 10: Deploy the Model</strong></h3>
<p>Once our model is refined and performing well, the next step is to deploy it in a real-world scenario, which typically involves the following steps:</p>
<ul>
<li><strong>Integrate the model into an application or API:</strong> This allows the model to make predictions either in real time or in batch mode, depending on the specific needs of the system.</li>
<li><strong>Monitor the model’s performance:</strong> Continuously tracking the model’s effectiveness on new data helps identify any performance drops or changes in data patterns.</li>
<li><strong>Periodic model updates:</strong> The model may need to be retrained with new data or fine-tuned to maintain its accuracy and relevance as conditions evolve.</li>
</ul>
<p>Our demo has skipped through <a href="#step-9-refine-the-model">step 9</a> and <a href="#step-10-deploy-the-model">10</a>, as the project was designed solely for academic and tutorial purposes. Consequently, the results achieved are not intended to be final or satisfactory for production use.</p>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion"><strong>Conclusion</strong></h3>
<p>In this tutorial, we’ve covered the complete machine learning process using the Pima Indians Diabetes Dataset as a practical example. We explored how to define the problem, collect, split, and preprocess the data, train a model, evaluate its performance, and refine it for improved performance. Each of these steps is essential for building a robust machine learning model capable of solving real-world problems.</p>
<p>Machine learning is an iterative and evolving process that involves continuous experimentation and refinement. As you advance in your data science journey, the principles outlined in this tutorial will guide you in tackling more complex challenges and making data-driven decisions.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>